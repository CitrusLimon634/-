当多个用户使用数据库资源时，同时运行着多个事务需处理，多事务的执行方式主要有三类：

* 事务串行执行，每时刻只有一个事务执行，这不利于充分发挥系统效率；
* 交叉并发方式，单处理机中多事务同时交叉执行，能减少处理机闲置时间，提高效率；
* 同时并发方式，多处理机中同时运行多个事务，实现真正的并发，是最理想的模式，但受制于硬件环境，需要更复杂的处理机制。

事务并发执行可能会导致存取不正确的数据，破坏事务的**隔离性**和数据库的**一致性**。
并发操作主要带来三类数据不一致性：

##### 丢失修改

丢失修改指事务1与事务2从数据库中**读入同一数据并修改**。事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。

##### 读“脏”数据

读脏数据指事务1修改某一数据，并将其写回磁盘。事务2读取同一数据后，事务1**由于某种原因被撤消**，这时事务1**已修改**过的数据**恢复原值**，事务2读到的数据就与数据库中的数据不一致，是不正确的数据，又称为“脏”数据。

##### 不可重复读

不可重复读指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。

在数据库环境下，并发控制的主要方式是封锁机制，即加锁

#### 加锁

**基本锁**类型有两种：排它锁（Exclusive Locks）和共享锁（Share Locks）

* **共享锁**（S锁或读锁）：若事务T对数据对象A加了S锁，则事务T可以读数据A，但不能修改A，**其它事务只能再对A加S锁，而不能加X锁**，直到事务T释放了A上的S锁；
* **排它锁**（X锁或写锁）：若事务T对数据对象A加了X锁，则允许T读取和修改A，但**不允许其它事务**再对A**加任何类型的锁和进行任何操作**；



#### 封锁协议

在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，如：
何时申请X锁或S锁；
事务的持锁时间、何时释放锁；
称这些规则为封锁协议或加锁协议
不同的封锁协议，在不同的程度上为并发操作的正确调度提供了一定的保证。
常用的封锁协议：三级封锁协议

###### 一级封锁协议

对事务T要**修改的数据加X锁**，直到事务结束（包括正常和非正常结束）时才释放。
一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。 
但如果事务T只是读数据而不修改数据，则不需要加锁，所以一级封锁协议不能保证可重复读和不读“脏”数据。

###### 二级封锁协议

一级封锁协议＋对事务T对要**读取的数据先加S锁**，**读完后即可释放S锁**。
除了可以防止丢失修改外，还可以防止读“脏”数据。
但在二级封锁协议协议中，由于事务T读完数据即释放S锁，因此，不能保证可重复读数据。

###### 三级封锁协议

一级封锁协议＋事务T对要**读取的数据加S锁，并直到事务结束才释放**。
三级封锁协议除了可以防止丢失数据修改和不读“脏”数据之外，还可进一步防止不可重复读。 

#### 并发调度的可串行性 

* 计算机系统对并行事务中并行操作的调度是的**随机**的，而不同调度可能会产生不同的结果。
* 按不同顺序串行执行的事务有**可能产生不同的结果**，但**不会将数据库置于不一致状态**，因此，事务串行执行都被认为是正确的。
* 多个事务**并发执行是正确**的，**当且仅当**其结果**与**按某一顺序的**串行执行的结果相同**，则称这种调度为可串行化的调度。

例：
事务T~1~：读B；A=B+1；写回A
事务T~2~：读A；B=A+1；写回B
两个正确结果 -->  初值均为4：T~1~->T~2~,A=5,B=6；T~2~->T~1~,A=6,B=5

#### 两段锁(Two-Phase Locking)协议

是实现并发调度可串行化调度的充分条件。
两段锁协议内容：在对任何数据进行**读、写操作之前**，事务先要获得对该数据的**封锁**，在释放一个封锁之后，事务**不再获得任何其他封锁**。
该协议将每个事务分成两个时期：**申请封锁期**和**释放封锁期**，申请期申请要进行的封锁，不允许释放任何锁；释放期释放所占有的封锁，不允许再申请任何锁，这就是两段式封锁。

#### 两段锁和三级封锁的区别

两类不同目的的协议：
两段锁协议：保证事务并发调度结果的正确性。
三级封锁协议：在不同程度上保证多个事务并发访问时事务的隔离性和数据的一致性不被破坏。
遵守第三级封锁协议必然遵守两段锁协议。



#### 活锁和死锁

封锁技术可以有效地解决事务并行操作中数据一致性问题，但也带来一些新的问题：
活锁：T1封锁数据R，T2请求封锁R，T2等待；T3也请求封锁R，T1释放R，系统先批准了T3的请求，T2 仍等待；T4也请求封锁R，T3释放R，系统又先批准了T4的请求，…，T2可能一直等待；
死锁：两个事务相互等待对方先释放资源，则会造成死锁；

##### 活锁

* **活锁产生的原因**：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无期限等待某个封锁，从而导致活锁。
* 当多个事务请求封锁同一数据段时，采用**先来先服务**的**策略**：
  按请求封锁的先后次序对这些事务排队。
  该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

##### 死锁

* **死锁产生的原因**：两个或多个事务都已封锁了一些数据对象，然后又都相互请求已被对方封锁的数据对象加锁，从而出现死等待。
* **预防死锁**就是破坏产生死锁的条件，操作系统中预防死锁策略有多种，常用的有两种：
  * 一次封锁法，每个事务一次将所有要使用的数据全部加锁，否则就不能继续执行；
  * 顺序封锁法，预先对数据对象规定一个封锁顺序，所有事务都按这个顺序封锁；