

#### 基本格式

```sql
SELECT <列> FROM <表>
WHERE <行选择条件>
GROUP BY <分组依据列>
HAVING <组选择条件>
ORDER BY <排序依据列>
```

重点：**查询语句的基本结构、多表连接查询、子查询（嵌套查询）**

#### 查询语句的基本结构

1. 消除取值相同的行
   DISTINCT：去掉结果中的重复行。
   DISTINCT放在SELECT词的后边、目标列名序列的前边。
2. 查询满足条件的元组

| 查询条件   | 谓   词                                        |
| ---------- | ---------------------------------------------- |
| 比较运算符 | =,   >, >=, <,   <=, <>（或!=） NOT+比较运算符 |
| 确定范围   | BETWEEN…AND,   NOT BETWEEN…AND                 |
| 确定集合   | IN,   NOT IN                                   |
| 字符匹配   | LIKE,   NOT LIKE                               |
| 空值       | IS NULL,   IS NOT NULL                         |
| 多重条件   | AND, OR                                        |

如果要查找的字符串正好含有通配符，比如下划线或百分号，就需要使用一个特殊子句来告诉数据库管理系统这里的下划线或百分号是一个普通的字符，而不是一个通配符，

```sql
ESCAPE 转义字符
```



3. 对查询结果进行排序 

   ```sql
   ORDER BY <列名> [ASC | DESC ] 
   [,<列名> … ]
   ```

4. 使用计算函数汇总数据 COUNT( * )：统计表中元组个数；
   COUNT( [DISTINCT] <列名> )：统计本列值个数；
   SUM( [DISTINCT] <列名> )：计算列值总和；
   AVG( [DISTINCT] <列名> )：计算列值平均值；
   MAX( [DISTINCT] <列名> )：求列值最大值； 
   MIN( [DISTINCT] <列名> )：求列值最小值。
   计算函数不能出现在WHERE子句中

5. 对查询结果进行分组计算 

   ```sql
   [GROUP BY <分组条件>]
   [HAVING <组过滤条件>] 
   ```

   分组查询的结果列：要么是分组的依据列，要么是计算函数构成的列，因为分组后**每个组只返回一行结果**。
   **按多列分组**

   ```sql
   SELECT Sdept, Ssex, Count(*) as 人数,
   Max(Sage) 最大年龄 FROM Student
   GROUP BY Sdept, Ssex
   ORDER BY Sdept 
   ```

   使用HAVING
   HAVING用于对分组自身进行限制，它有点象条件查询中的WHERE子句，但它**应用于组**而不是对单个记录或整个表

#### 多表连接查询

###### 内连接

两个表的相关字段满足连接条件
```sql
SELECT … FROM 表名 [INNER] JOIN 被连接表
ON 连接条件
```

###### 自连接

必须指定别名

```sql
FROM 表1 AS T1
JOIN 表2 AS T2
```

###### 外连接

左外连接，左边的表不需要满足连接条件

```sql
FROM  表1  LEFT | RIGHT  [OUTER] JOIN  表2
ON  <连接条件>
```

##### 使用TOP限制结果集 

```sql
TOP n [percent]  [with TIES]
```

若使用了WITH TIES，必须使用ORDER BY排序

#### 子查询（嵌套查询）

###### 基于集合

列名  [NOT]  IN (子查询) 

###### 比较测试 

当用户能确切知道内层查询**返回的是单值**时，可用>、<、=、>=、<=、<>等比较运算符来连接子查询

###### 存在性测试 

* 带EXISTS谓词的子查询不返回查询的数据，只产生逻辑真值（有数据）和假值（没有数据）
* EXISTS的子查询只返回真或假值，因此子查询中给出具体的列名无意义。所以在有EXISTS的子查询中，其目标列表达式**一般都用 *  表示**
* 处理过程为**先外后内**（无条件执行外层查询）；由外层的值执行内层的查询；若内层查询返回真值，则外层表中的当前行数据为满足条件的结果

##### 将查询结果保存到新表中

必须为聚合函数起别名

```sql
SELECT 查询列表序列 INTO <新表名>
FROM 数据源
…    -- 其他行选择、分组等语句
```

用INTO子句创建的新表可以是永久表。临时表又根据其使用范围分为两种：

###### 局部临时表

通过在表名前加一个“#”来标识。
生存期为创建此局部临时表的连接的生存期,
只能在创建局部临时表的当前连接中使用；

###### 全局临时表

通过在表名前加两个“#”来标识。
生存期为创建全局临时表的连接的生存期，
在生存期内可以被所有的连接使用。 

##### 查询结果的并、交、差运算

1. 使用 UNION可以实现将多个查询结果集合并为一个结果集|

   ```sql
   SELECT 语句1
   UNION [ ALL ]
   SELECT 语句2
   UNION [ ALL ]
   … …
   SELECT语句n
   ```

   所有查询语句中列的个数和列的顺序必须相同。
   所有查询语句中对应列的**数据类型**必须**兼容**。
   ORDER BY语句要放在最后一个查询语句的后边。

2. 查询结果的交运算
   将两个查询结果中**各列值均相同**的记录返回

   ```sql
   SELECT 语句1
   INTERSECT
   SELECT 语句2
   INTERSECT
   … …
   SELECT语句n
   ```

3. 查询结果的差运算

   使用EXCEPT可以实现返回在一个查询结果中有，而另一个查询集中没有的记录
   
   ```sql
   SELECT 语句1
   EXCEPT
   SELECT 语句2
   EXCEPT
   … …
   SELECT语句n
   ```
   
   
